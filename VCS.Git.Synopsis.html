<!DOCTYPE html><html lang="en"><head><title>VCS Git Synopsis</title><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="css/bootstrap.min.css" rel="stylesheet"><style type="text/css">.color-back-black {
  background-color : rgb(0, 0, 0);
}
.color-text-white {
  color : #ffffff;
}
h1, h2, h3 {
  margin-top    : 0;
  margin-bottom : 0;
  color         : #942f11;
}
.h2, h2 {
  font-size : 24px;
}
/*.collapsing{color : rgb(169, 169, 169) }*/
[data-toggle]:hover {
  text-decoration : underline;
}
[data-toggle] {
  color            : #ffffff;
  background-color : #2d2d2d;
}
.collapse.in:hover {
  background-color : #f8f8f8 }
::-webkit-scrollbar {
  width    : 2px;
  position : fixed;
}
::-webkit-scrollbar-track {
  width         : 2px;
  border-radius : 10px;
}
::-webkit-scrollbar-thumb {
  border-radius    : 10px;
  background-color : #942f11;
}
body {
  min-height : 1200px;
  max-width  : 900px;
}</style></head><body class="container dl-horizontal"><h1> Preface</h1><dt> Description:</dt><dd> There are synopsis which i've gathered from my some notes and pieces of the<a href="http://git-scm.com/book/en/v2"> GIT Book (v2.0).</a></dd><dt> Version:</dt><dd> 2.0</dd><dt> Author:</dt><dd><a href="https://github.com/AlexNeodim">Alex Neodim</a></dd><hr><H1>1.      Getting started.</H1><H2 data-toggle="collapse" data-target="#13" aria-expanded="false" aria-controls="13">1.3.    Git Basics.</H2><div id="13" class="collapse"><dt>   Snapshots.</dt><dd>Every time you commit, or save the state of your project in Git,
it basically takes a picture of what all your files look like at that moment
and stores a reference to that snapshot (if files have not changed,</dd><dd>Git doesn't store the file again (like others VCSs),
just a link to the previous identical file it has already stored.)</dd><dd>   Git thinks about its data more like a stream of snapshots.</dd><dt>   Nearly Every Operation Is Local.</dt><dd>Git only need local files and resources to operate unlike
other VCSs which have latency network overhead.</dd><dt>   Git Has Integrity.</dt><dt>   Git Generally Only Adds Data.</dt><dd>   In Git, doing nearly all of actions, you only add data to the Git database.</dd><dd>It is very difficult to lose your data,
especially if you regularly push your database to another repository.</dd><dd>Everything (files, dirs) in Git is check-summed before it's stored (to GIT) and
is then referred to by that checksum.</dd><dd>   This means it’s impossible to change the contents without Git knowing about it.</dd><dd>   Git hash-mechanism: SHA-1</dd><dd>   Git stored snapshots in DB by the hash.</dd></div><hr><h1>2.      Git Basics.</h1><H2 data-toggle="collapse" data-target="#21" aria-expanded="false" aria-controls="21">2.1.     Getting a Git Repository</H2><div id="21" class="collapse"><p></p><dt>  Git initializing in an Existing Directory</dt><dd>   Init in a current directory: [$ git init]</dd><dt>  Cloning an Existing Repository.</dt><dd>   You clone a repository with: [$ git clone [url]].</dd></div><H2 data-toggle="collapse" data-target="#22" aria-expanded="false" aria-controls="22">2.2.    Recording Changes to the Repository</H2><div id="22" class="collapse"><dt>   Recording Changes to the Repository</dt><dd><p>  Current dir - directory where git had initialized.</p><ul> Each file in the current directory may have two states:<ul><li>    untracked(не отслеживаемые)</li><li>    tracked  (отслеживаемые, in last snapshot)</li></ul></ul><ul>  Tracked files are files that were of the last snapshot; their states:<ul><li>      unmodified</li><li>      modified</li><li>      staged</li></ul></ul></dd><dt> Checking the Status of Your Files</dt><dd>     Check status of files in current dir: [$ git status]</dd><dt>  Tracking New Files</dt><dd>     Begin tracking new file:[ $ git add [file]]</dd><dt> Staging Modified Files</dt><dd>     Git add is a multipurpose command – you use it to begin tracking new files,</dd><dd>     to stage files, and to do other things like marking merge-conflicted files as resolved.</dd><dt> Ignoring Files</dt><dd>     See .gitignore</dd><dt> Viewing Your Staged and Unstaged Changes</dt><dd>     [$ git diff] - shows you the exact lines added and removed – the patch, as it were.</dd><dt> Removing Files</dt><dd>Command: [$ git rm [file | dir]]
This command simply delete tracked file.</dd><dt>  Moving Files (Renaming)</dt><dd>If you want to rename a file in Git, you can run something like:
[$ git mv file_from file_to]</dd></div><H2 data-toggle="collapse" data-target="#23" aria-expanded="false" aria-controls="23">2.3.   Viewing the Commit History.</H2><div id="23" class="collapse"><dt>   Viewing the Commit History</dt><dd>   To do this you need type the [$ git log] command.</dd><dd>   One of the more helpful options is [-p], which shows the difference introduced in each commit.</dd><dd>   You can also use [-2], which limits the output.</dd><dd>   If you want to see some abbreviated stats for each commit, you can use the [--stat] option.</dd><dd>   Another really useful option is [--pretty=oneline|short|full|fuller|format:]</dd><dd>   Show graph: [$ git log --graph]</dd><dd>   e.g.: [$ git log --pretty=format:"%h - %an, %ar : %s"]</dd><dd>   More info available on the above link.</dd><dd>   To see only the commits of a certain author: git log --author=bob</dd><dd>   Different between committer and author is the author is the person who originally wrote the work,</dd><dd>   whereas the committer is the person who last applied the work.</dd><dt>     Limiting Log Output</dt><dd>With: [-<n>] where n is any integer to show the last n commits.
The time-limiting options such as --since and --until.
See other command in reference.</dd></div><H2 data-toggle="collapse" data-target="#24" aria-expanded="false" aria-controls="24">2.4.    Undoing Things</H2><div id="24" class="collapse"><dt>   Undoing Things</dt><dd>   [$ git commit --amend]</dd><dt>   Unstaging a Staged File</dt><dd>   To unstage content in current dir, you can use: [$ git reset HEAD <file>] command:</dd><dt>   Unmodifying a Modified File</dt><dd>   You can replace local changes using the command:</dd><dd>   [$ git checkout -- [file]] - be careful - is a dangerous command.</dd><dd>   This kept files already added to the index,(new files).</dd><dd>   Remember, anything that is committed in Git can almost always be recovered.</dd><dd>If you instead want to drop all your local changes, use:
[$ git fetch origin]. It fetch the latest history
from the server and point your local master branch.</dd></div><H2 data-toggle="collapse" data-target="#25" aria-expanded="false" aria-controls="25">2.5.     Working with Remotes</H2><div id="25" class="collapse"><dd>   Remote repositories are versions of your project</dd><dd>   that are hosted on the Internet or network somewhere.</dd><dd>   Remotes enable you collaborate on any project remotely.</dd><dd>   It is them porpose.</dd><dt>   Showing Your Remotes</dt><dd>   To see which remote servers you have configured, you can run the [$ git remote]</dd><dt>   Adding Remote Repositories</dt><dd>   [$ git remote add [shortname] [url]]</dd><dt>   Fetching and Pulling from Your Remotes</dt><dd>   As you just saw, to get data from your remote projects,</dd><dd>   you can run:[$ git fetch [remote-name]]</dd><dd>   For example, if you want to fetch all the information that remote repo has</dd><dd>   but that you don’t yet have in your repository, you can run [$ git fetch [shortname]]</dd><dd>   If you have a branch set up to track a remote branch, you can use</dd><dd>   the [$ git pull] command to automatically fetch and then merge a remote branch into your current branch.</dd><dt>   Pushing to Your Remotes</dt><dd>   When you have your project at a point that you want to share,</dd><dd>   you have to push it upstream. The command for this is simple:</dd><dd>   [git push [remote-name] [branch-name]]</dd><dt>   Inspecting a Remote</dt><dd>   If you want to see more information about a particular remote:</dd><dd>   [$ git remote show [remote-name] ]</dd></div><H2 data-toggle="collapse" data-target="#26" aria-expanded="false" aria-controls="26">2.6.    Tagging</H2><div id="26" class="collapse"><h2></h2><dt>   Tagging</dt><dd>     Typically people use this functionality to mark release points (v1.0, and so on).</dd><dt>   Listing Your Tags</dt><dd>     [$ git tag]</dd><dd>   You can also search for tags with a particualar pattern like this</dd><dd>   [$ git tag -l 'v1.*']</dd><dt>   Creating Tags</dt><dd>   Git uses two main types of tags:<li>lightweight</li><li>annotated.</li></dd><dd>   A lightweight tag is very much like a branch that doesn’t change – it’s just a pointer to a specific commit.</dd><dd>   Annotated tags, are stored as full objects in the Git database</dd><dd>   (including the tagger name, e-mail, date;</dd><dd>   a tagging message; and can be signed / verified with GNU Privacy Guard (GPG).)</dd><dt>   Annotated Tags</dt><dd>   The easiest way is to specify [-a | -m | -s ]: [$ git -a ]</dd><dd>   e.g.: [$ git tag -a v.1.4 - 'my version 1.4']</dd><dd>   To see tag data along with commit that was tagged, use: [$ git show [tagname]]</dd><dt>   Lightweight Tags</dt><dd>   To create a lightweight tag, don’t supply the -a, -s, or -m option, i.e:</dd><dd>   [$ git tag v1.4-lw]</dd><dt>   Tagging later</dt><dd>   [$ git tag -a [tagName] [commit]] i.e.:</dd><dd>   [$ git tag -a v1.2 9fceb02]</dd><dt>   Sharing Tags</dt><dd>   Just run: [$ git push origin [tagname]</dd><dd>   By default the [$ git push] command doesn’t transfer tags to remote servers.</dd><dd>   To push up at once a lot of tags you can use the:[$ git push --tags]</dd><dt>   Checking out Tags</dt><dd>   You can create a new branch at a specific tag:[$ git checkout -b [branchname] [tag(v.2 etc)]]</dd></div><H2 data-toggle="collapse" data-target="#27" aria-expanded="false" aria-controls="27">2.7.	Git Aliases</H2><div id="27" class="collapse"><dd>   You can easily set up an alias for each command using git config:</dd><dd>   [$ git config --global alias.[nameOfNewCommand] ["git.command]"]</dd><dd>   i.e.: [$ git config --global alias.co checkout]</dd><dd>   However, maybe you want to run an external command</dd><dd>   you start the command with a ! character.</dd><dd>   e.g.: [$ git config --global alias.visual "!gitk"]</dd></div><hr><h1>3. Git Branching</h1><H2 data-toggle="collapse" data-target="#31" aria-expanded="false" aria-controls="31">3.1.	Branching in a Nutshell.</H2><div id="31" class="collapse"><dd>   Branching means you diverge from the main line of development</dd><dd>   and continue to do work without messing with that main line.</dd><dt>   Branching in a Nutshell</dt><dd>   When you make a commit, Git stores a commit object that</dd><dd>   contains a pointer to the snapshot of the content you staged.</dd><dt>   Creating a New Branch</dt><dd>   [$ git branch [branch name]]</dd><dd>   How does Git know what branch you’re currently on?</dd><dd>   It keeps a special pointer called HEAD.</dd><dd>   Note that this is a lot different than the concept of HEAD</dd><dd>   in other VCSs you may be used to, such as Subversion or CVS.</dd><dd>   The git branch command only created a new branch – it didn’t switch to that branch.</dd><br><dd>   To see where the point of your HEAD, use:</dd><dd>   [$ git log --oneline --decorate]</dd><dd>   [$ git checkout [branch name]]</dd><dd>   That command did two things.</dd><dd>   It moved the HEAD pointer back to point to the [branch name] branch,</dd><dd>   and it reverted the files in your working directory</dd><dd>   back to the snapshot that master points to.</dd><dd>   [git log --oneline --decorate --graph --all]</dd></div><H2 data-toggle="collapse" data-target="#32" aria-expanded="false" aria-controls="32">3.2.	Basic Branching and Merging</H2><div id="32" class="collapse"><dt>   Basic Branching and Merging</dt><dd>   At this stage, you’ll receive a call that another issue</dd><dd>   is critical and you need a hotfix. You’ll do the following:<ol><li>Switch to your production branch.</li><li>Create a branch to add the hotfix.</li><li>After it’s tested, merge the hotfix branch, and push to production.</li><li>Switch back to your original story and continue working.</li></ol></dd><dt>   Basic Merging</dt><dd>   It’s worth pointing out that Git determines the best common ancestor to use</dd><dd>   for its merge base; this is different than older tools like CVS or Subversion (before version 1.5)</dd></div><h2 data-toggle="collapse" data-target="#33" aria-expanded="false" aria-controls="33">3.3.	Branch Management</h2><div id="33" class="collapse"><dd>Notice the <b>*</b> indicates the branch (HEAD) that you currently have checked out .</dd><dd>See last commit on each branch: [$ git branch -v]</dd></div><h2 data-toggle="collapse" data-target="#34" aria-expanded="false" aria-controls="34">3.3.	Branching Workflows</h2><div id="34" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows#Long-Running-Branches">Long-Running Branches</a></dt><dd>   This means you can have several branches that are always open (ie master) and</dd><dd>   that you use for different stages of your development cycle;</dd><dd>   you can merge regularly from some of them into others.</dd><dt></dt><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows#Topic Branches">Topic Branches</a></dt><dd>   Topic branches, however, are useful in projects of any size.</dd><dd>   A topic branch is a short-lived branch that you create and</dd><dd>   for a single particular feature or related work.</dd></div><h2 data-toggle="collapse" data-target="#35" aria-expanded="false" aria-controls="35">3.5.	Remote Branches</h2><div id="35" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">Remote Branches</a></dt><dd>   Remote branches are references (pointers) to the state of branches in your remote repositories.</dd><dd>   They’re local branches that you can’t move;</dd><dd>   they’re moved automatically for you whenever you do any network communication.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches#Tracking-Branches">Tracking Branches</a></dt><dd>   Checking out a local branch from a remote branch automatically creates what is called</dd><dd>   a “tracking branch” (or sometimes an “upstream branch”).</dd><dd>   Tracking branches are local branches that have a direct relationship to a remote branch.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches#Deleting-Remote-Branches">Deleting Remote Branches</a></dt><dd> If you want to delete your branch from the server, you run the following:</dd><dd> [$ git push [remote name] --delete [branch name]]</dd></div><h2 data-toggle="collapse" data-target="#36" aria-expanded="false" aria-controls="36">3.6.	Rebasing</h2><div id="36" class="collapse"><dd>In Git, there are two main ways to integrate changes from one branch into another:<ol><li>the merge</li><li>the rebase.</li></ol></dd><dt>   The Basic Rebase</dt><dd>   There is no difference in the end product (in comparing with merge tool)</dd><dd>   of the integration, but rebasing makes for a cleaner history.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Basic-Rebase">The Basic Rebase</a></dt><dd>  Commands:
  [$ git<a href="http://git-scm.com/docs/git-rebase">   rebase</a>  --onto <newbase>]</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing">The Perils of Rebasing</a></dt><dd>Do not rebase commits that exist outside your repository.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing#Rebase-When-You-Rebase">Rebase When You Rebase</a></dt><dd></dd></div><hr><h1>4. Git on the Server</h1><h2 data-toggle="collapse" data-target="#41" aria-expanded="false" aria-controls="41">4.1.	The Protocols</h2><div id="41" class="collapse"><dd>   Therefore, the preferred method for collaborating with someone</dd><dd>   is to set up an intermediate repository that you both have access to, and push to and pull from that.</dd></div><hr><h1> Misc</h1><H2 data-toggle="collapse" data-target="#Misc" aria-expanded="false" aria-controls="Misc">Misc</H2><div id="Misc" class="collapse"><dt>     GPG</dt><dd>     - GNU Privacy Guard</dd><dd>     Head  - points to the last commit i have made.</dd><dd>     Index - is the current state of file of current dir</dd><dd>     that will comprise next commit (in other words - staged area, or</dd><dd>     is the last snapshot of files in the current dir.</dd><dt>     Useful hints:</dt><dd><ol><li> [$ gitk]                            - built-in git GUI</li><li> [$ git config color.ui true]        - use colorful git output</li><li> [$ git config format.pretty oneline]- show log on just one line per commit</li><li> [$ git add -i]                      - use interactive adding</li></ol></dd><dt>     Other</dt><dd><ul><li>  adding for tracking(or staging) : git add [dir]</li><li>  dChecking status                : git status</li><li>  dChecking status (short)        : git status -s</li></ul></dd></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script><script src="js/bootstrap.min.js"></script></body></html>