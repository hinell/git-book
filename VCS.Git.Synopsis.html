<!DOCTYPE html><html lang="en"><head><title>VCS Git Synopsis</title><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="css/bootstrap.min.css" rel="stylesheet"><style type="text/css">.color-back-black {
  background-color : rgb(0, 0, 0);
}
.color-text-white {
  color : #ffffff;
}
h1, h2, h3 {
  margin-top    : 0;
  margin-bottom : 0;
  color         : #F29C00;
  background-color: #000000;
  font-size: 25px;

}
.text-color-black {
  color:#000000;
}
.text-whitespaces {
  white-space : pre;
}

.h2, h2 {
  font-size : 20px;
}
/*.collapsing{color : rgb(169, 169, 169) }*/
[data-toggle]:hover {
  text-decoration : underline;
}
[data-toggle] {
  color            : #ffffff;
  background-color : #2d2d2d;
}
.collapse.in:hover {
  background-color : #f8f8f8 }
::-webkit-scrollbar {
  width    : 2px;
  position : fixed;
}
::-webkit-scrollbar-track {
  width         : 2px;
  border-radius : 10px;
}
::-webkit-scrollbar-thumb {
  border-radius    : 10px;
  background-color : #F29C00;
}
body {
  min-height : 1200px;
  max-width  : 900px;
}</style></head><body class="container dl-horizontal"><h1>     SUMMARY</h1><H2 data-toggle="collapse" data-target="#Preface" aria-controls="Preface">Preface</H2><div id="Preface" class="collapse"><dt>   Description:</dt><dd>  Here a small review of my some collected notes based on the<a href="http://git-scm.com/book/en/v2"> GIT Book (v2.0),</a></dd><dt>   Version:</dt><dd>   2.0</dd><dt>   Author:</dt><dd><a href="https://github.com/AlexNeodim">Alex Neodim</a></dd></div><H1>     1.      Getting started.</H1><H2 data-toggle="collapse" data-target="#13" aria-controls="13">1.3.    Git Basics.</H2><div id="13" class="collapse"><dt>   Snapshots.</dt><dd>Every time you commit, or save the state of your project in Git,
it basically takes a picture of what all your files look like at that moment
and stores a reference to that snapshot (if files have not changed,</dd><dd>Git doesn't store the file again (like others VCSs),
just a link to the previous identical file it has already stored.)</dd><dd>   Git thinks about its data more like a stream of snapshots.</dd><dt>   Nearly Every Operation Is Local.</dt><dd>Git only need local files and resources to operate unlike
other VCSs which have latency network overhead.</dd><dt>   Git Has Integrity.</dt><dt>   Git Generally Only Adds Data.</dt><dd>   In Git, doing nearly all of actions, you only add data to the Git database.</dd><dd>It is very difficult to lose your data,
especially if you regularly push your database to another repository.</dd><dd>Everything (files, dirs) in Git is check-summed before it's stored (to GIT) and
is then referred to by that checksum.</dd><dd>   This means it’s impossible to change the contents without Git knowing about it.</dd><dd>   Git hash-mechanism: SHA-1</dd><dd>   Git stored snapshots in DB by the hash.</dd></div><h1>     2.      Git Basics.</h1><H2 data-toggle="collapse" data-target="#21" aria-controls="21">2.1.     Getting a Git Repository</H2><div id="21" class="collapse"><p></p><dt>  Git initializing in an Existing Directory</dt><dd>   Init in a current directory: [$ git init]</dd><dt>  Cloning an Existing Repository.</dt><dd>   You clone a repository with: [$ git clone [url]].</dd></div><H2 data-toggle="collapse" data-target="#22" aria-controls="22">2.2.    Recording Changes to the Repository</H2><div id="22" class="collapse"><dt>   Recording Changes to the Repository</dt><dd><p>  Current dir - directory where git had initialized.</p><ul> Each file in the current directory may have two states:<ul><li>    untracked(не отслеживаемые)</li><li>    tracked  (отслеживаемые, in last snapshot)</li></ul></ul><ul>  Tracked files are files that were of the last snapshot; their states:<ul><li>unmodified</li><li>modified</li><li>staged</li></ul></ul></dd><dt>   Checking the Status of Your Files</dt><dd>       Check status of files in current dir: [$ git status]</dd><dt>    Tracking New Files</dt><dd>       Begin tracking new file:[ $ git add [file]]</dd><dt>   Staging Modified Files</dt><dd>       Git add is a multipurpose command – you use it to begin tracking new files,</dd><dd>       to stage files, and to do other things like marking merge-conflicted files as resolved.</dd><dt>   Ignoring Files</dt><dd>       See .gitignore</dd><dt>   Viewing Your Staged and Unstaged Changes</dt><dd>       [$ git diff] - shows you the exact lines added and removed – the patch, as it were.</dd><dt>   Removing Files</dt><dd>Command: [$ git rm [file | dir]]
This command simply delete tracked file.</dd><dt>  Moving Files (Renaming)</dt><dd>If you want to rename a file in Git, you can run something like:
[$ git mv file_from file_to]</dd></div><H2 data-toggle="collapse" data-target="#23" aria-controls="23">2.3.   Viewing the Commit History.</H2><div id="23" class="collapse"><dt>   Viewing the Commit History</dt><dd>   To do this you need type the [$ git log] command.</dd><dd>   One of the more helpful options is [-p], which shows the difference introduced in each commit.</dd><dd>   You can also use [-2], which limits the output.</dd><dd>   If you want to see some abbreviated stats for each commit, you can use the [--stat] option.</dd><dd>   Another really useful option is [--pretty=oneline|short|full|fuller|format:]</dd><dd>   Show graph: [$ git log --graph]</dd><dd>   e.g.: [$ git log --pretty=format:"%h - %an, %ar : %s"]</dd><dd>   More info available on the above link.</dd><dd>   To see only the commits of a certain author: git log --author=bob</dd><dd>   Different between committer and author is the author is the person who originally wrote the work,</dd><dd>   whereas the committer is the person who last applied the work.</dd><dt>   Limiting Log Output</dt><dd>With: [-n] where n is any integer to show the last n commits.
The time-limiting options such as --since and --until.
See other command in reference.</dd></div><H2 data-toggle="collapse" data-target="#24" aria-controls="24">2.4.    Undoing Things</H2><div id="24" class="collapse"><dt>   Undoing Things</dt><dd>   [$ git commit --amend]</dd><dt>   Unstaging a Staged File</dt><dd>   To unstage content in current dir, you can use: [$ git reset HEAD <file>] command:</dd><dt>   Unmodifying a Modified File</dt><dd>   You can replace local changes using the command:</dd><dd>   [$ git checkout -- [file]] - be careful - is a dangerous command.</dd><dd>   This kept files already added to the index,(new files).</dd><dd>   Remember, anything that is committed in Git can almost always be recovered.</dd><dd>If you instead want to drop all your local changes, use:
[$ git fetch origin]. It fetch the latest history
from the server and point your local master branch.</dd></div><H2 data-toggle="collapse" data-target="#25" aria-controls="25">2.5.     Working with Remotes</H2><div id="25" class="collapse"><dd>   Remote repositories are versions of your project</dd><dd>   that are hosted on the Internet or network somewhere.</dd><dd>   Remotes enable you collaborate on any project remotely.</dd><dd>   It is them porpose.</dd><dt>   Showing Your Remotes</dt><dd>   To see which remote servers you have configured, you can run the [$ git remote]</dd><dt>   Adding Remote Repositories</dt><dd>   [$ git remote add [shortname] [url]]</dd><dt>   Fetching and Pulling from Your Remotes</dt><dd>   As you just saw, to get data from your remote projects,</dd><dd>   you can run:[$ git fetch [remote-name]]</dd><dd>   For example, if you want to fetch all the information that remote repo has</dd><dd>   but that you don’t yet have in your repository, you can run [$ git fetch [shortname]]</dd><dd>   If you have a branch set up to track a remote branch, you can use</dd><dd>   the [$ git pull] command to automatically fetch and then merge a remote branch into your current branch.</dd><dt>   Pushing to Your Remotes</dt><dd>   When you have your project at a point that you want to share,</dd><dd>   you have to push it upstream. The command for this is simple:</dd><dd>   [git push [remote-name] [branch-name]]</dd><dt>   Inspecting a Remote</dt><dd>   If you want to see more information about a particular remote:</dd><dd>   [$ git remote show [remote-name] ]</dd></div><H2 data-toggle="collapse" data-target="#26" aria-controls="26">2.6.    Tagging</H2><div id="26" class="collapse"><h2></h2><dt>   Tagging</dt><dd>     Typically people use this functionality to mark release points (v1.0, and so on).</dd><dt>   Listing Your Tags</dt><dd>     [$ git tag]</dd><dd>   You can also search for tags with a particualar pattern like this</dd><dd>   [$ git tag -l 'v1.*']</dd><dt>   Creating Tags</dt><dd>   Git uses two main types of tags:<li>     lightweight</li><li>     annotated.</li></dd><dd>   A lightweight tag is very much like a branch that doesn’t change – it’s just a pointer to a specific commit.</dd><dd>   Annotated tags, are stored as full objects in the Git database</dd><dd>   (including the tagger name, e-mail, date;</dd><dd>   a tagging message; and can be signed / verified with GNU Privacy Guard (GPG).)</dd><dt>   Annotated Tags</dt><dd>   The easiest way is to specify [-a | -m | -s ]: [$ git -a ]</dd><dd>   e.g.: [$ git tag -a v.1.4 - 'my version 1.4']</dd><dd>   To see tag data along with commit that was tagged, use: [$ git show [tagname]]</dd><dt>   Lightweight Tags</dt><dd>   To create a lightweight tag, don’t supply the -a, -s, or -m option, i.e:</dd><dd>   [$ git tag v1.4-lw]</dd><dt>   Tagging later</dt><dd>   [$ git tag -a [tagName] [commit]] i.e.:</dd><dd>   [$ git tag -a v1.2 9fceb02]</dd><dt>   Sharing Tags</dt><dd>   Just run: [$ git push origin [tagname]</dd><dd>   By default the [$ git push] command doesn’t transfer tags to remote servers.</dd><dd>   To push up at once a lot of tags you can use the:[$ git push --tags]</dd><dt>   Checking out Tags</dt><dd>   You can create a new branch at a specific tag:[$ git checkout -b [branchname] [tag(v.2 etc)]]</dd></div><H2 data-toggle="collapse" data-target="#27" aria-controls="27">2.7.	Git Aliases</H2><div id="27" class="collapse"><dd>   You can easily set up an alias for each command using git config:</dd><dd>   [$ git config --global alias.[nameOfNewCommand] ["git.command]"]</dd><dd>   i.e.: [$ git config --global alias.co checkout]</dd><dd>   However, maybe you want to run an external command</dd><dd>   you start the command with a ! character.</dd><dd>   e.g.: [$ git config --global alias.visual "!gitk"]</dd></div><h1>     3. Git Branching</h1><H2 data-toggle="collapse" data-target="#31" aria-controls="31">3.1.	Branching in a Nutshell.</H2><div id="31" class="collapse"><dd>   Branching means you diverge from the main line of development</dd><dd>   and continue to do work without messing with that main line.</dd><dt>   Branching in a Nutshell</dt><dd>   When you make a commit, Git stores a commit object that</dd><dd>   contains a pointer to the snapshot of the content you staged.</dd><dt>   Creating a New Branch</dt><dd>   [$ git branch [branch name]]</dd><dd>   How does Git know what branch you’re currently on?</dd><dd>   It keeps a special pointer called HEAD.</dd><dd>   Note that this is a lot different than the concept of HEAD</dd><dd>   in other VCSs you may be used to, such as Subversion or CVS.</dd><dd>   The git branch command only created a new branch – it didn’t switch to that branch.</dd><br><dd>   To see where the point of your HEAD, use:</dd><dd>   [$ git log --oneline --decorate]</dd><dd>   [$ git checkout [branch name]]</dd><dd>   That command did two things.</dd><dd>   It moved the HEAD pointer back to point to the [branch name] branch,</dd><dd>   and it reverted the files in your working directory</dd><dd>   back to the snapshot that master points to.</dd><dd>   [git log --oneline --decorate --graph --all]</dd></div><H2 data-toggle="collapse" data-target="#32" aria-controls="32">3.2.	Basic Branching and Merging</H2><div id="32" class="collapse"><dt>   Basic Branching and Merging</dt><dd>   At this stage, you’ll receive a call that another issue</dd><dd>   is critical and you need a hotfix. You’ll do the following:<ol><li>Switch to your production branch.</li><li>Create a branch to add the hotfix.</li><li>After it’s tested, merge the hotfix branch, and push to production.</li><li>Switch back to your original story and continue working.</li></ol></dd><dt>   Basic Merging</dt><dd>   It’s worth pointing out that Git determines the best common ancestor to use</dd><dd>   for its merge base; this is different than older tools like CVS or Subversion (before version 1.5)</dd></div><h2 data-toggle="collapse" data-target="#33" aria-controls="33">3.3.	Branch Management</h2><div id="33" class="collapse"><dd>   Notice the <b>*</b> indicates the branch (HEAD) that you currently have checked out .</dd><dd>   See last commit on each branch: [$ git branch -v]</dd></div><h2 data-toggle="collapse" data-target="#34" aria-controls="34">3.3.	Branching Workflows</h2><div id="34" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows#Long-Running-Branches">Long-Running Branches</a></dt><dd>   This means you can have several branches that are always open (ie master) and</dd><dd>   that you use for different stages of your development cycle;</dd><dd>   you can merge regularly from some of them into others.</dd><dt></dt><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows#Topic Branches">Topic Branches</a></dt><dd>   Topic branches, however, are useful in projects of any size.</dd><dd>   A topic branch is a short-lived branch that you create and</dd><dd>   for a single particular feature or related work.</dd></div><h2 data-toggle="collapse" data-target="#35" aria-controls="35">3.5.	Remote Branches</h2><div id="35" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">Remote Branches</a></dt><dd>   Remote branches are references (pointers) to the state of branches in your remote repositories.</dd><dd>   They’re local branches that you can’t move;</dd><dd>   they’re moved automatically for you whenever you do any network communication.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches#Tracking-Branches">Tracking Branches</a></dt><dd>   Checking out a local branch from a remote branch automatically creates what is called</dd><dd>   a “tracking branch” (or sometimes an “upstream branch”).</dd><dd>   Tracking branches are local branches that have a direct relationship to a remote branch.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches#Deleting-Remote-Branches">Deleting Remote Branches</a></dt><dd>   If you want to delete your branch from the server, you run the following:</dd><dd>   [$ git push [remote name] --delete [branch name]]</dd></div><h2 data-toggle="collapse" data-target="#36" aria-controls="36">3.6.	Rebasing</h2><div id="36" class="collapse"><dd>   In Git, there are two main ways to integrate changes from one branch into another:<ol><li>the merge</li><li>the rebase.</li></ol></dd><dt>   The Basic Rebase</dt><dd>   There is no difference in the end product (in comparing with merge tool)</dd><dd>   of the integration, but rebasing makes for a cleaner history.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Basic-Rebase">The Basic Rebase</a></dt><dd>  Commands:
  [$ git<a href="http://git-scm.com/docs/git-rebase">   rebase</a>  --onto <newbase>]</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing">The Perils of Rebasing</a></dt><dd>Do not rebase commits that exist outside your repository.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-Branching-Rebasing#Rebase-When-You-Rebase">Rebase When You Rebase</a></dt><dd></dd></div><h1>     4. Git on the Server</h1><h2 data-toggle="collapse" data-target="#41" aria-controls="41">4.1.	The Protocols</h2><div id="41" class="collapse"><dd>   Therefore, the preferred method for collaborating with someone</dd><dd>   is to set up an intermediate repository that you both have access to, and push to and pull from that.</dd><dt>   The Protocols</dt><dd>   Git can use four major protocols to transfer data:<ul><li><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols#Local-Protocol">Local</a></li><li><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols#The-HTTP-Protocols">HTTP</a></li><li><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols#The-SSH-Protocol">Secure Shell (SSH)</a></li><li><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols#The-Git-Protocol">Git</a></li></ul></dd><dd></dd></div><h2 data-toggle="collapse" data-target="#42" aria-controls="42">4.2. Getting Git on a Server</h2><div id="42" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server">Getting Git on a Server</a></dt><dd>   In order to initially set up any Git server,</dd><dd>   you have to export an existing repository into a new bare repository –</dd><dd>   a repository that doesn’t contain a working directory.</dd><dd>   This is generally straightforward to do.</dd><dd>   By convention, bare repository directories end in .git</dd><dd>   In order to clone repo, you run clone command with --bare:</dd><dd>   [$ git clone --bare [url to repo] [cloned repo name].git ]</dd><dd>   This is roughly equivalent to something like</dd><dd>   [$ cp -Rf my_repo/.git my_local_repo.git]</dd><dd>   Git will automatically add group write permissions to a repository properly</dd><dd>   if you run the git init command with the --shared option:</dd><dd>   [$ git init --bare --shared]</dd><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server#Putting-the-Bare-Repository-on-a-Server">Putting the Bare Repository on a Server
</a></dt><dd>   Let’s say you’ve set up a server called git.example.com</dd><dd>   Further you can set up your new repository by copying your bare repository over:</dd><dd>   [$ scp -r my_project.git user@git.example.com:[/path/to/new/repo]]</dd><dd>   After all, now, user's who have SSH acsess to the same serve</dd><dd>   can clone your repository by running</dd><dd>   [$ git clone user@git.example.com:[/path/to/new/repo].git]</dd><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server#Small-Setups">Small Setups</a></dt><dd>   One of the most complicated aspects of setting up a Git server is user management.</dd><dt>   SSH Access</dt><dd>   There are a few ways you can give access to everyone on your team:<ul><li> Just set up accounts (obviously system) for everybody.</li><li>Create a signle git user on the machine and ask every user who
is to have write access to send you an SSH public key,
and add that key to the ~/.ssh/authorized_keys</li><li>Another way to do it is to have your SSH server
authenticate from an LDAP server or some other
centralized authentication source that you may already have set up.

</li></ul></dd></div><h2 data-toggle="collapse" data-target="#43" aria-controls="43">4.3. Generating Your SSH Public Key</h2><div id="43" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Generating-Your-SSH-Public-Key">Generation SSH key</a></dt><dd>   First, you should check to make sure you don’t already have a key.</dd><dd>   By default, a user's SSH key are stored in that user's ~/.ssh directory</dd><dd>   and key's files named like id_dsa or id_rsa and a matching file with a</dd><dd>   .pub extension.</dd><dd>   If you don't have these files, you can create them by program called ssh-keygen:</dd><dd>   [$ ssh-keygend -t rsa -C "your@email.com"];</dd><dd>   which  provided on almost all current system platform (Linux/Mac, on NT with MSysGit package).</dd><dd>   Now, each user that does this has to send their public key to the Git server</dd><dd>   (assuming you’re using an SSH server setup that requires public keys).</dd><dd>   All they have to do is compy the content of the .pub file and send it.</dd><dt><a href="https://help.github.com/articles/generating-ssh-keys.">GitHub article</a></dt><dd>   Click to open up help for SSH key generation on GitHub Help service.</dd></div><h2 data-toggle="collapse" data-target="#44" aria-controls="44">4.4. Setting Up the Server</h2><div id="44" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server">Setting Up the Server</a></dt><dd>   First, you create (on Nix-systems - you also should create a git user) a .ssh directory for that user.</dd><dd>   Next, you need to add some developer SSH public keys to the ~/.ssh/authorized_keys directory.</dd><dd>   Now, you can set up an empty repository.</dd></div><h2 data-toggle="collapse" data-target="#45" aria-controls="45">4.5. Git Daemon</h2><div id="45" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Git-Daemon">Git Daemon</a></dt><dd>   In any case, the Git protocol is relatively easy to set up.</dd><dd>   Basically, you need to run this command in a daemonized manner:</dd><dd>   Remember that since it’s not an authenticated service,</dd><dd>   anything you serve over this protocol is public within its network.</dd><dd>   --reuseaddr allows the server to restart without waiting for old connections to time out</dd><dd>   --base-path option allows people to clone projects without specifying the entire path</dd><dd>   and the path at the end tells the Git daemon where to look for repositories to export.</dd><dd></dd></div><h2 data-toggle="collapse" data-target="#46" aria-controls="46">4.6. Smart HTTP</h2><div id="46" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Smart-HTTP">Smart HTTP</a></dt><dd>   Setting up Smart HTTP is basically just enabling</dd><dd>   a CGI script that is provided with Git called [git-http-backend] on the server.</dd></div><h2 data-toggle="collapse" data-target="#47" aria-controls="47">4.7. GitWeb</h2><div id="47" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-GitWeb">GitWeb</a></dt><dd>   Git comes with a CGI script called GitWeb that is</dd><dd>   provided simple web-based visualizer.</dd></div><h2 data-toggle="collapse" data-target="#48" aria-controls="48">4.8. GitLab</h2><div id="48" class="collapse"><dd>   If you’re looking for a more modern, fully featured Git server,</dd><dd>   there are some several open source solutions out there that you can install instead.</dd><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-GitLab#Installation">Installation</a></dt><dd>   GitLab is a database-backed web application</dd><dd>   To get something up and running quickly, you can download a virtual machine image or</dd><dd>   a one-click installer from https://bitnami.com/stack/gitlab,</dd><dd>   and tweak the configuration to match your particular environment.</dd></div><h2 data-toggle="collapse" data-target="#49" aria-controls="49">4.9. Third Party Hosted Options</h2><div id="49" class="collapse"><dt><a href="http://git-scm.com/book/en/v2/Git-on-the-Server-Third-Party-Hosted-Options"></a>  Third Party Hosted Options</dt><dd>   These days, you have a huge number of hosting options to choose from.</dd><dd>   To see an up-to-date list, check out the GitHosting page on the main<a href="https://git.wiki.kernel.org/index.php/GitHosting">  Git wiki</a></dd></div><h1>     5. Distributed Git</h1><h2 data-toggle="collapse" data-target="#51" aria-controls="51">5.1. Distributed Workflows</h2><div id="51" class="collapse"><dt>   Distributed Workflows</dt><dd>   Unlike another centralized VCS, GIT allows every developer to be</dd><dd>   on both a node and a hub states.</dd><dd>   So lets cover a few common paradigms of workflow:</dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows#Centralized-Workflow">Centralized Workflow</a></dt><dd><img src="http://www.shaney.net/git/images/centralized.png" class="img-responsive img-rounded"></dd><dd>   One central hub, or repository, can accept code, and everyone synchronizes their work to it.</dd><dd>   This is also not limited to small teams.</dd><hr><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows#Integration-Manager-Workflow">Integration-Manager Workflow</a></dt><dd><img src="http://git-scm.com/book/en/v2/book/05-distributed-git/images/integration-manager.png" class="img-responsive img-rounded"></dd><dd></dd><dd>   Because Git allows you to have multiple remote repositories,</dd><dd>   it’s possible to have a workflow where each developer</dd><dd>   has write access to their own public repository and read access to everyone else’s.</dd><dd>   The process works as follows:</dd><dd><ol><li>The project maintainer pushes to their public repository.</li><li> A contributor clones that repository and makes changes.</li><li> The contributor pushes to their own public copy.</li><li> The contributor sends the maintainer an e-mail asking them to pull changes.</li><li> The maintainer adds the contributor’s repo as a remote and merges locally.</li><li> The maintainer pushes merged changes to the main repository.</li></ol></dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows#Dictator-and-Lieutenants-Workflow">Dictator and Lieutenants Workflow</a></dt><dd><img src="http://git-scm.com/book/en/v2/book/05-distributed-git/images/benevolent-dictator.png" class="img-responsive img-rounded"></dd><dd>   This is a variant of a multiple-repository workflow.</dd><dd>   It’s generally used by huge projects with hundreds of collaborators;</dd><dd>   Various integration managers are in charge of certain parts of the repository;</dd><dd>   they’re called lieutenants.</dd><dd>   All the lieutenants have one integration manager known as the benevolent dictator.</dd><dd>   The process works like this:<ol><li>Regular developers work on their topic branch and rebase their work on top of master. The master branch is that of the dictator.</li><li>Lieutenants merge the developers’ topic branches into their master branch.</li><li>The dictator merges the lieutenants’ master branches into the dictator’s master branch.</li><li>The dictator pushes their master to the reference repository so the other developers can rebase on it.</li></ol></dd></div><h2 data-toggle="collapse" data-target="#52" aria-controls="52">5.2. Contributing to a Project</h2><div id="52" class="collapse"><dt>   Contributing to a Project</dt><dd>   The main difficulty with describing how to contribute to a project</dd><dd>   is that there are a huge number of variations on how it’s done.</dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines">Commit Guidelines</a></dt><dd>   Before we start looking at the specific use cases, here’s a quick note about commit messages.</dd><dd>   First, you don’t want to submit any whitespace errors.</dd><dd>   Before you commit, run [$ git diff --check] -</dd><dd>   It is identifies possible whitespace errors and lists them for you.</dd><dd>   Next, try to make each commit a logically separate changeset.</dd><dd>   If you can, try to make your changes digestible – don’t code for a whole weekend on five different issues</dd><dd>   and then submit them all as one massive commit on Monday.</dd><dd>   The last thing to keep in mind is the commit message.</dd><dd>   Here is a template originally written by Tim Pope:</dd><dd><blockquote class="text-whitespaces">Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
  preceded by a single space, with blank lines in
  between, but conventions vary here</blockquote></dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Private-Small-Team">Private Small Team</a></dt><dd>   Before pushing changes from your local repo at the meantime as this doing another developers,</dd><dd>   you need fetch remote changes and then merge with your.</dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Private-Managed-Team">Private Managed Team</a></dt><dd>   The ability of smaller subgroups of a team to collaborate via</dd><dd>   remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.</dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Forked-Public-Project">Forked Public Project</a></dt><dd>   [$ git merge --no-commit --squash]</dd><dd>   The --squash option takes all the work on the merged branch</dd><dd>   and squashes it into one non-merge commit on top of the branch you’re on.</dd><dt><a href="http://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project#Public-Project-over-E-Mail">Public Project over E-Mail</a></dt><dd>   You can generate e-mail versions of each commit series and e-mail them to the developer mailing list</dd></div><h1> Related terms</h1><H2 data-toggle="collapse" data-target="#Misc" aria-controls="Misc">Misc</H2><div id="Misc" class="collapse"><dt>     GPG</dt><dd>     - GNU Privacy Guard</dd><dd>     HEAD  is the pointer that points to the current branch or any a commit.</dd><dd>     todo: it's need to be revised</dd><dd>     INDEX is the current state of files of repository which to be included to next commit</dd><dt>     Useful hints:</dt><dd><ol><li> [$ gitk]                            - built-in git GUI</li><li> [$ git config color.ui true]        - use colorful git output</li><li> [$ git config format.pretty oneline]- show log on just one line per commit</li><li> [$ git add -i]                      - use interactive adding</li><li> [$ git gui]</li></ol></dd><dt>     Other</dt><dd><ul><li>  adding for tracking(or staging) : git add [dir]</li><li>  dChecking status                : git status</li><li>  dChecking status (short)        : git status -s</li></ul></dd><dt>     git-shell</dt><dd>     It is the shell that used instead the default system platform (bash) shell</dd><dd>     to the git-server authorization process. (chapter 4.4.)</dd><dd>     For security reasons.</dd></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script><script src="js/bootstrap.min.js"></script><h1 class="text-color-black">.</h1></body></html>