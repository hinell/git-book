VCS GIT. Based on http://git-scm.com/book/en/v2

Temp:
Chapter
	Part Chapter along with Header
	Paragraph
		Body of.

1.      Getting started.
1.3.    Git Basics.
		Snapshots.
			Every time you commit, or save the state of your project in Git,
			it basically takes a picture of what all your files look like at that moment
			and stores a reference to that snapshot (if files have not changed,
			Git doesn't store the file again (like others VCSs),
			just a link to the previous identical file it has already stored.)
			Git thinks about its data more like a stream of snapshots.

		Nearly Every Operation Is Local.
			Git only need local files and resources to operate unlike
			other VCSs which have latency network overhead.

		Git Has Integrity.
		Git Generally Only Adds Data.
			In Git, doing nearly all of actions, you only add data to the Git database.
			It is very difficult to lose your data,
			especially if you regularly push your database to another repository.
			Everything (files, dirs) in Git is check-summed before it's stored (to GIT) and
			is then referred to by that checksum.
			This means it’s impossible to change the contents without Git knowing about it.
			Git hash-mechanism: SHA-1
			Git stored snapshots in DB by the hash.


2.      Git Basics.
2.1     Getting a Git Repository
		Git initializing in an Existing Directory
			Init in a current directory: [$ git init]
		Cloning an Existing Repository.
			You clone a repository with: [$ git clone [url]].

2.2.    Recording Changes to the Repository
		Recording Changes to the Repository
			Current dir - directory where git had initialized.
			Each file in the current directory may have two states:
				untracked(не отслеживаемые)
				tracked  (отслеживаемые, in last snapshot)
			Tracked files are files that were of the last snapshot; their states:
			    unmodified
			    modified
			    staged

		Checking the Status of Your Files
			Check status of files in current dir: [$ git status]

		Tracking New Files
			Begin tracking new file:[ $ git add [file]]

		Staging Modified Files
			Git add is a multipurpose command – you use it to begin tracking new files,
			to stage files, and to do other things like marking merge-conflicted files as resolved.

		Ignoring Files
			See .gitignore

		Viewing Your Staged and Unstaged Changes
			[$ git diff] - shows you the exact lines added and removed – the patch, as it were.

		Removing Files
			Command: [$ git rm [file | dir]]
			This command simply delete tracked file.

		Moving Files (Renaming)
			If you want to rename a file in Git, you can run something like:
			[$ git mv file_from file_to]

2.3.    Viewing the Commit History: git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History
		Viewing the Commit History
			To do this you need type the [$ git log] command.
			One of the more helpful options is [-p], which shows the difference introduced in each commit.
			You can also use [-2], which limits the output.
			If you want to see some abbreviated stats for each commit, you can use the [--stat] option.
			Another really useful option is [--pretty=oneline|short|full|fuller|format:]
			Show graph: [$ git log --graph]
			e.g.: [$ git log --pretty=format:"%h - %an, %ar : %s"]
			More info available on the above link.

			To see only the commits of a certain author: git log --author=bob

			Different between committer and author is the author is the person who originally wrote the work,
			whereas the committer is the person who last applied the work.

		Limiting Log Output
			With: [-<n>] where n is any integer to show the last n commits.
			The time-limiting options such as --since and --until.
			See other command in reference.


2.4.    Undoing Things
		Undoing Things
			[$ git commit --amend]

		Unstaging a Staged File
			To unstage content in current dir, you can use: [$ git reset HEAD <file>] command:

		Unmodifying a Modified File
			You can replace local changes using the command:
			[$ git checkout -- [file]] - be careful - is a dangerous command.
			This kept files already added to the index,(new files).
			Remember, anything that is committed in Git can almost always be recovered.

			If you instead want to drop all your local changes, use:
			[$ git fetch origin]. It fetch the latest history
			from the server and point your local master branch.

2.5.     Working with Remotes
			Remote repositories are versions of your project
			that are hosted on the Internet or network somewhere.
			Remotes enable you collaborate on any project remotely.
			It is them porpose.

		Showing Your Remotes
			To see which remote servers you have configured, you can run the [$ git remote]

		Adding Remote Repositories
			[$ git remote add [shortname] [url]]
		Fetching and Pulling from Your Remotes
			As you just saw, to get data from your remote projects,
			you can run:[$ git fetch [remote-name]]

			For example, if you want to fetch all the information that remote repo has
			but that you don’t yet have in your repository, you can run [$ git fetch [shortname]]
			If you have a branch set up to track a remote branch, you can use

			the [$ git pull] command to automatically fetch and then merge a remote branch into your current branch.


3.1.	Branching in a Nutshell: http://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell#_git_branching
			Branching means you diverge from the main line of development
			and continue to do work without messing with that main line.

		Branching in a Nutshell
			When you make a commit, Git stores a commit object that
			contains a pointer to the snapshot of the content you staged.

		Creating a New Branch
			[$ git branch [branch name]]
			How does Git know what branch you’re currently on?
			It keeps a special pointer called HEAD.
			Note that this is a lot different than the concept of HEAD
			in other VCSs you may be used to, such as Subversion or CVS.
			The git branch command only created a new branch – it didn’t switch to that branch.
			To see where the point of your HEAD, use:
			[$ git log --oneline --decorate]

			[$ git checkout [branch name]]
			That command did two things.
			It moved the HEAD pointer back to point to the [branch name] branch,
			and it reverted the files in your working directory
			back to the snapshot that master points to.

			[git log --oneline --decorate --graph --all]





My notes.
		Head  - points to the last commit i have made.
		Index - is the current state of file of current dir
		that will comprise next commit (in other words - staged area, or
		is the last snapshot of files in the current dir.

		Useful hints:
			[$ gitk]                            - built-in git GUI
			[$ git config color.ui true]        - use colorful git output
			[$ git config format.pretty oneline]- show log on just one line per commit
			[$ git add -i]                      - use interactive adding


		adding for tracking(or staging) : git add [dir]
		dChecking status                : git status
		dChecking status (short)        : git status -s



